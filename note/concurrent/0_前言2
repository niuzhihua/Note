了解了执行指令的流水线技术，我们接着探索。

    不可预测的控制流
        我们知道了流水线条数的增加 使得CPU的吞吐率得到的提高，处理的指令也就多了。但是带有长流水线的CPU想要达到最佳性能，
        需要程序给出高度可预测的控制流。  因此可预测的控制流影响着CPU的处理速度。
        如果程序中
                    带有许多循环， 且循环计数都比较小
                    或者面向对象的程序中带有许多虚方法， 每个虚方法都可以引用不同的对象实例，而这些对象实例都实现了一些频繁被调用的成员函数
        此时CPU很难或者完全不可能预测某个分支的走向。这样CPU要么等待控制流进行到足以知道分支走向的方向， 要么干脆猜测， 由于此时程序的控制流
        不可预测， CPU常常猜错。 在这两种情况下， 流水线都会被排空，CPU需要等待流水线被新指令填充， 这将大幅降低CPU的性能。

        总结：程序中不可预测的控制流 导致CPU等待控制流分支的方向 或者 猜测，导致流水线被排空, CPU需要等待流水线被新指令填充。
              因此，不可预测的控制流降低了CPU的性能

    内存引用
        在2006年， 同样是读取内存里一个值的时间， 微处理器可以在这段时间执行上百条甚至上千条指令。由于读内存的速度 比 cpu执行一条指令的速度慢很多。
        简化理解：即内存速度比CPU速度 慢很多。  因此引入了CPU高速缓冲 来减少了内存访问延迟。但是只有高度可预测的数据访问模式才能让缓存发挥最大效用。

        总结：内存引用常常对CPU性能造成严重影响

        以上是CPU在单线程代码中执行时会遭遇的性能障碍。接下来是多线程会为CPU带来额外的性能障碍。

    原子操作：
        拜硬件设计者的精密设计所赐，CPU使用了很多非常聪明的手段让一些指令“看起来”是原子的。
        常见的技巧是标出所有包含原子操作所需数据的流水线，确保所有这些流水线都属于正在执行原子操作的CPU，并且只有在这些流水线仍归该
        CPU所有时才推进原子操作的执行。这样看起来， 因为所有数据都只属于该CPU， 即使CPU流水线可以同时执行多条指令，
        其他CPU也无法干扰此CPU的原子操作执行。不用多说， 这种技巧要求流水线必须能被延迟或者冲刷， 这样才能执行让原子操作正确完成的一系列操作。

        非原子操作则与之相反， CPU可以从流水线中按照数据出现的顺序读取并把结果放入缓冲区， 无须等待流水线的归属切换。
        虽然CPU设计者已经 对原子操作进行了优化 ， 但是原子操作任然影响CPU性能。

    内存屏障：
        原子操作通常只用于单个变量，由于并行计算经常需要更新多个变量，保证正确的执行顺序， 因此大多数 CPU都提供了内存屏障。
        内存屏障也是影响性能的因素之一。

        内存屏障的作用是防止CPU为了提升性能而进行的乱序执行，所以内存屏障一定会降低CPU性能。

    高速缓存未命中
        现代CPU使用大容量的高速缓存来降低由于较低的内存访问速度带来的性能惩罚。但是， CPU高速缓存事实上对 多CPU间频繁访问变量 起到了反效果。
        因为当某个CPU想去更改变量的值时， 极有可能该变量的值刚被其他CPU修改过。 在这种情况下， 变量存在于其他CPU而不是当前CPU的高速缓存中，
        这将导致代价高昂的高速缓存未命中。

        缓存未命中也是影响CPU性能的主要原因。

    I/O操作
        缓存未命中可以视为CPU之间的I/O操作， 这应该是代价最低廉的 I/O操作之一。I/O操作涉及网络、 大容量存储器等。
        I/O操作对性能的影响远远大于之前几节提到的各种障碍

    ------------------------------------------------------------------------------------------------

    内存屏障的详细语义在不同CPU架构之间的变化是很大的， 幸运的是， 所有 CPU架构都遵从如下规则:

    1． 一个特定CPU的所有访问操作都与该CPU上的编程顺序一致。
    3． 内存屏障以成对的形式进行操作。

    内存屏障有4个基本变种。
        1． 写（或存储） 内存屏障
        2． 数据依赖屏障
        3． 读（或加载） 内存屏障
        4． 通用内存屏障 : 同时对加载和存储操作进行排序。隐含读和写内存屏障， 因此也可以替换它们中的任何一个。

    内存屏障使用规则:
        1、必须 配对使用。
            写屏障    <---配对--->   数据依赖屏障/读屏障/通用屏障
            读屏障/数据依赖屏障  <---配对--->  至少一个写屏障/通用屏障
        2、必须有读屏障， 即使它可能是一个弱的读屏障。

        例子：
            cpu0        cpu1           或者       cpu0        cpu1
            a = 1                                 a = 1
            <写屏障>                              <写屏障>
            b = 2                                 b = a
                        x = b                               x = b
                        <读屏障>                            <数据依赖屏障>
                        y = a                               y = x

    内存屏障 TODO()：
        1、成对屏障
        写屏障之前的存储通常预期来匹配 读屏障或者数据依赖屏障之后的加载， 反之亦然
        读屏障或者数据依赖屏障 之前的存储 通常预期来匹配 写屏障之后的加载
        例子：
            store:存储    load：加载/装载

            cpu1                        cpu2
            store a = 1                load v = c
            store b = 2                load w = d

            <写屏障>                   <读屏障>
            store c = 3                load x = a
            store d = 4                load y = b


        2、写屏障仅仅对写操作的顺序有效
            store a = 1
            store b = 2
            <写屏障>   // 保证了 写屏障之前的存储操作  在下面的存储语句被处理之前  完成。
            store c = 3
            store d = 4

        3、数据依赖屏障仅仅对数据依赖装载操作有效
             假设初始化：b=7， x=9， x=8， c=＆y

            cpu1                            cpu2
            store a = 1
            store b = 2
            <写屏障>
            store c = &b
            store d = 4                     感知：c->&b // c指向b
                                            感知：b = 7 // 对b的感知不正确。因为没有屏障进行干涉的话，cpu2不理会cpu1发出的写屏障，可能会以随机感知变量。
                                                     TODO(注意是不理会cpu1发出的写屏障)
                                            感知：x = 9
                                            感知：b = 2
            ----------------------------------------------------------------------------------------------------------------------------
            cpu1                            cpu2
            store a = 1
            store b = 2
            <写屏障>
            store c = &b
            store d = 4
                                            load c
                                            <读屏障/数据依赖屏障>655.
                                            x = 9
                                            b = 2