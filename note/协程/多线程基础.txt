

可见性：多核时代的cpu都有自己的缓存，CPU 缓存会导致可见性问题。


原子性：1、一个或多个操作在CPU执行过程中不被中断的特性，叫原子性。
        2、现代的操作系统都是基于线程来实现任务切换的，任务切换也就是指线程切换。
        3、注意CPU能保证的原子操作是CPU指令级别的，而不是高级语言的每一个行代码。

        线程切换导致了原子性问题。


        解决方案：
        1、互斥锁：synchronized ,加锁的本质是在对象的头中写入当前线程的id.

           同一时刻，只有一个线程执行，也就是互斥，如果能够保证对共享变量的修改操作是互斥的，
           那么就能保证原子性了。



        2、CAS指令(无锁方式)：CPU为了解决并发问题，提供了CAS(Compare and Swap)指令，CAS指令能够保证原子性。

           CAS指令包括三个参数：
                共享变量的内存地址A
                用于比较的值B
                共享变量的新值C
           CAS 操作在java 中是靠原子类 来实现的。 在 包  java.util.concurrent.atomic 下。

           原子类分类：
                原子类基本数据类型     : 例如  AtomicInteger
                原子类对象引用类型     : 例如  AtomicReference
                原子类数组             : 例如  AtomicIntegerArray
                原子化的累加器         : 例如  LongAdder
                原子化的对象属性更新器  : 例如 AtomicIntegerFieldUpdater

            CAS 操作带来的ABA问题： 暂时不关心， 解决思路：增加版本号。

        3、不变性/Copy-On-Write 模式:

        4、不共享变量方式：

有序性：程序代码编译过程中，编译器会进行编译优化，会调整代码语句的顺序(代码顺序或CPU指令顺序)，
        但不影响执行结果。这可能会导致 bug产生。

        编译优化带来了有序性问题。





