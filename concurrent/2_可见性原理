
    背景1：如果保证一个处理器 在任意时刻 可以获取其他处理器的最新数据 (我们把这叫做存储一致性)，那么其代价非常高昂。
         于是cpu架构做了妥协， 用 cpu缓存一致性 来代替 存储一致性，这样做 代价可以接受，并且运算性能得到提升。
         但是操作系统，编译器，运行时 ，应用程序都得将就 这种 妥协 ，那就是硬件提供的cpu缓存机制  与 线程安全需求(存储一直性)
         之间的差异。

         什么是cpu缓存一致性：
                在多处理器架构种，每个处理器都有自己的缓存，并且周期性的与 内存协调一致，，，，，，TODO()
         cpu缓存一致性意义： 提高了计算性能。
         cpu缓存一致性原理 ： 用cpu缓存协议来实现，例如 ：mesi协议。


    背景2：随着硬件的不断发展，处理器制造商纷纷转向多核处理器，原因是cpu的时钟频率很难经济的提高了，
          可以提升的只有cpu的并行处理能力。#此外，重排序后的指令使得在计算性能上得到了很大的提升。

          现代计算机计算性能得到很大提升的因素：
          #对指令的重排序 ：有利于 1、优化执行 2、有利于使用成熟的寄存器分配算法
          越来越高的cpu时钟频率
          采用多核cpu的并行计算

          并行计算提高了运行指令时的吞吐率，执行指令时不再时顺序执行，而是乱序执行。乱序执行 解决了 顺序执行带来的阻塞问题。

          乱序执行 ：指令执行的先后顺序，不再和它们在程序中的顺序有关。

          顺序执行带来的阻塞问题 ：
                 由于数据的依赖关系和指令先后执行的顺序问题，很多时候，流水线不得不“阻塞”在特定的指令上。
                 即使后续别的指令，并不依赖正在执行的指令和阻塞的指令，也不能继续执行。
          乱序执行解决 ：
                 乱序执行，则是在指令执行的阶段通过一个类似线程池的保留站，让系统自己去动态调度先执行哪些指令。
                 这个动态调度巧妙地解决了流水线阻塞的问题。

          乱序执行需要满足的条件： 数据、指令之间的依赖关系不能被破坏。

          如何满足？
                CPU 在指令结果的最终提交的阶段， 通过 重排序 的方式，确保不破坏 指令数据、指令之间的依赖关系，
                从而表现为“实际上”是顺序执行的。
                数据依赖性：分为3种
                        写后读 ： a = 1         // 写入a
                                  b = a         // 读取a
                        读后写 :   a = b       // 读取b
                                   b = 3       // 写入b
                        写后写 :   a = 2       //  写入 a
                                   a = 4        // 写入 a
                编译器、处理器在重排序时，会遵守数据的依赖性，不会改变 有数据依赖性的 操作的  执行顺序。

          什么是重排序？
                    提到重排序，就必须提as-if-serial语义 。
                    as-if-serial定义： 1、不管怎么重排序，单线程程序的执行结果不能被改变。
                    在遵守as-if-serial语义 前提下 进行 代码或指令的排序。

          重排序包括：
                编译器优化带来的重排序。
                指令被并行执行时的重排序。
                内存系统重排序。

          重排序影响
                1、重排序解决了 乱序执行时数据、指令之间依赖关系的问题.
                2、由于进行了重排序，指令的执行次序无法得知，在多线程环境下 会改变执行结果，这就影响计算结果的正确性。
                    为何改变执行结果 ？
                    经过重排序后，某个线程 读取的可能不是最新值，而是过期值 ，这也是 破坏可见性的原因。

          总结：TODO()

         0、为什么在单线程环境下可以保证可见性？

                因为 重排序 遵守 数据间的 依赖关系。即重排序 遵守 as-if-serial语义。

                在单线程模式下的代码  :
                        int a = 3       // 行1 : A
                        int b = 4       // 行2 : B
                        int c = a * b   // 行3 : C
                c 和 a 、c和 b 有依赖关系， a 和 b 没有依赖关系。
                那么 行3 不能重排序到 行1、行2 前面 ,  行1、行2 可以重排序。

                执行过程可能为两种情况：
                        A -> B -> C
                        B -> A -> C
                总结：在单线程环境下，由于 重排序遵守as-if-serial语义 ，有依赖关系的不会被重排序，因此保证了可见性。

         可见性在多线程环境下无法保证的原因是什么？TODO()

         如何解决多线程环境下的可见性问题？
             我们知道了引发可见性的原因是 重排序，而重排序是为了提高性能一定要做的，这就引出了 一种简约的、理想化的、模型：
             顺序化一致性 模型。 实现了 顺序化一致性 模型 ，也就保证了 可见性。

             顺序化一致性模型： 65页 继续读
                    1、每个 线程 执行的顺序是唯一的 ，就是它们出现在程序中的顺序。
                    2、变量的每一次读操作，都能够得到 这个变量的最新值，不论这个值是那个处理器写入的。

         如何实现顺序化一致性模型？

                    1、学习重排序 指令规则，学习各个硬件系统平台的 重排序 指令规则 , 利用这些规则、指令
                        在各个平台上实现 顺序化一致性 模型 。重排序规则很复杂，对程序员很不友好。很遗憾，这太难了。

                    2、Java帮我们实现好了，直接用。

                       在Java中，由Java内存模型JMM来实现，JMM定义了 happens-before 规则，一个happens-before规则对应 一个或多个
                       编译器、处理器的重排序 规则，只要我们满足了 这个规则，我们的程序 就满足了 顺序化一致性 ，也就保证了可见性。
                       因此， happens-before规则非常重要。

                       Java内存模型(JMM)决定了一个线程对共享变量的写入 何时 对另一个线程可见。即JMM来解决。

         happens-before规则概述：操作A 的结果 对 操作B 可见 , 叫做 A happens-before B. 并不一定要 A在B前执行。

                    程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
                    监视器锁规则：对一个锁的解锁 操作，happens-before于随后对这个锁的加锁 操作。
                    volatile规则：对volatile变量的写操作，happens-before于 后续对这个volatile变量的读操作。
                    传递规则：如果A操作 happens-before B，且B happens-before C，那么A happens-before C。
                    线程启动、中断、终止法则 ：
                    对象终结法则：析构函数 happens-before 于 构造函数的结束。

            从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。
            在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。


         对于开发者来说如何实现或满足 happens-before规则？TODO()
            锁的内存语义
            final域的内存语义
            volatile的内存语义


        问：如何保证(多线程在操作可变共享变量时的)可见性?
        答：满足顺序化一致性 模型 即可保证可见性，在Java中，由JMM中定义的 happens-before规则 来实现顺序化一致性模型。
            简而言之， 满足happens-before规则 就保证了可见性。


        在多线程环境下实现可见性的底层原理是什么？
        答：内存屏障 + cpu缓存一致性协议








