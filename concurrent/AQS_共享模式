前面了解了以独占的方式获取state变量，下面再看看以共享的方式来获取、释放 state。

    两种方式的对比
    独占                              共享
    只能有一个线程获取state成功        多个线程获取state成功

AQS：
    int tryAquireShared(int) : AQS子类来实现，共享式的获取state. 忽略线程中断。
    boolean tryReleaseShared(int) : AQS子类来实现,共享式的释放state.

    void acquireShared(int arg) ：给同步工具调用
    boolean releaseShared(int arg) ：给同步工具调用

    源码分析：
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)  // 如果共享式的获取state 成功
            doAcquireShared(arg);
    }

    private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);   // 创建Node,线程安全的添加到队尾。 node就是尾节点喽。
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();  // node:当前节点就是尾节点   p:当前节点的前节点。
                if (p == head) {           // 前节点是头节点
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }

                switch(前节点P.waitStatus){
                     SIGNAL :    //值为-1
                         阻塞当前线程, 当前线程就是 node节点里的线程喽。
                         interrupted = true
                         return true
                     CANCELLED :  //值为1 ：  waitStatus>0 不就是 waitStatus==1
                         就删除P节点: 效果看图
                         break
                     defalut:    // 0、-2、-3
                         更新前节点P ：waitStatus = SIGNAL
                         // TODO(由此可见， 获取state成功即正在运行的线程 的waitStatus 的值，是被当前线程修改为SIGNAL状态的。)
                         // TODO(由于是死循环，第一次循环：修改为SIGNAL状态 。第二次循环： 检测到前节点P.waitStatus 为SIGNAL，当前线程就阻塞了。 )
                         break
                     }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }